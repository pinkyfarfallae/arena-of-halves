{"version":3,"file":"static/js/895.37d97a54.chunk.js","mappings":"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","sources":["components/DiceRoller/D4/TetrahedronDie.tsx","components/DiceRoller/D4/D4Scene.tsx"],"sourcesContent":["import { useEffect, useMemo, useRef } from 'react';\nimport { useFrame } from '@react-three/fiber';\nimport * as THREE from 'three';\n\ninterface Props {\n  rollTrigger: number;\n  onResult: (result: number) => void;\n  primary: string;\n  primaryDark: string;\n}\n\nconst FACE_RESULTS = [1, 2, 3, 4];\n\n/*\n * Regular tetrahedron with front face normal = +Z (facing camera).\n * v0 = top of front face\n * v1 = bottom-left of front face\n * v2 = bottom-right of front face\n * v3 = apex behind\n */\nconst S = 1.3;\nconst rt3 = Math.sqrt(3);\nconst rt6 = Math.sqrt(6);\n\nconst V0: THREE.Vector3Tuple = [0, S * 2 / rt3, S * rt6 / 6];\nconst V1: THREE.Vector3Tuple = [-S, -S / rt3, S * rt6 / 6];\nconst V2: THREE.Vector3Tuple = [S, -S / rt3, S * rt6 / 6];\nconst V3: THREE.Vector3Tuple = [0, 0, -S * rt6 / 2];\n\n// Faces: [vertices] — CCW winding from outside\nconst FACES: THREE.Vector3Tuple[][] = [\n  [V0, V1, V2], // front  (normal ≈ +Z)\n  [V0, V3, V1], // left   (normal ≈ -X)\n  [V0, V2, V3], // right  (normal ≈ +X)\n  [V1, V3, V2], // bottom (normal ≈ -Y/-Z)\n];\n\n/** Compute flat face normal from 3 vertices */\nfunction computeNormal(a: THREE.Vector3Tuple, b: THREE.Vector3Tuple, c: THREE.Vector3Tuple): THREE.Vector3 {\n  const va = new THREE.Vector3(...a);\n  const vb = new THREE.Vector3(...b);\n  const vc = new THREE.Vector3(...c);\n  return vb.sub(va).cross(vc.sub(new THREE.Vector3(...a))).normalize();\n}\n\nconst NORMALS = FACES.map(f => computeNormal(f[0], f[1], f[2]));\n\n/** Parse hex/rgb to [r,g,b] 0-255 */\nfunction parseColor(color: string): [number, number, number] {\n  const rgbMatch = color.match(/rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)\\)/);\n  if (rgbMatch) return [+rgbMatch[1], +rgbMatch[2], +rgbMatch[3]];\n  const h = color.replace('#', '');\n  const n = parseInt(h.length === 3 ? h.split('').map(c => c + c).join('') : h, 16);\n  return [(n >> 16) & 255, (n >> 8) & 255, n & 255];\n}\n\n/** Relative luminance (0 = black, 1 = white) */\nfunction luminance(color: string): number {\n  const [r, g, b] = parseColor(color).map(c => {\n    const s = c / 255;\n    return s <= 0.03928 ? s / 12.92 : Math.pow((s + 0.055) / 1.055, 2.4);\n  });\n  return 0.2126 * r + 0.7152 * g + 0.0722 * b;\n}\n\n/** Pick best contrasting text color for a given background */\nfunction contrastText(bg: string): string {\n  const lum = luminance(bg);\n  if (lum > 0.85) return bg;\n  return lum > 0.4 ? '#000000' : '#ffffff';\n}\n\n/** Flat primary face with number baked in */\nfunction makeFaceTexture(num: number, primary: string): THREE.CanvasTexture {\n  const size = 512;\n  const canvas = document.createElement('canvas');\n  canvas.width = size;\n  canvas.height = size;\n  const ctx = canvas.getContext('2d')!;\n\n  ctx.fillStyle = primary;\n  ctx.fillRect(0, 0, size, size);\n\n  const textColor = contrastText(primary);\n  ctx.fillStyle = textColor;\n  ctx.font = 'bold 140px sans-serif';\n  ctx.textAlign = 'center';\n  ctx.textBaseline = 'middle';\n  ctx.fillText(String(num), size / 2, size * 2 / 3);\n\n  const tex = new THREE.CanvasTexture(canvas);\n  tex.needsUpdate = true;\n  return tex;\n}\n\n/** Darken a color by mixing toward black */\nfunction darken(color: string, ratio: number): string {\n  const [r, g, b] = parseColor(color);\n  const m = (c: number) => Math.round(c * (1 - ratio));\n  return `rgb(${m(r)},${m(g)},${m(b)})`;\n}\n\n/** Vertex Y range for gradient mapping */\nconst ALL_VERTS = [V0, V1, V2, V3];\nconst MIN_Y = Math.min(...ALL_VERTS.map(v => v[1]));\nconst MAX_Y = Math.max(...ALL_VERTS.map(v => v[1]));\n\n/** Build a cylinder mesh between two points with vertex-color gradient */\nfunction makeEdgeCylinder(a: THREE.Vector3Tuple, b: THREE.Vector3Tuple, radius: number, baseColor: THREE.Color): THREE.CylinderGeometry {\n  const va = new THREE.Vector3(...a);\n  const vb = new THREE.Vector3(...b);\n  const height = va.distanceTo(vb);\n  const geo = new THREE.CylinderGeometry(radius, radius, height, 8, 1);\n\n  // Brightness at each endpoint based on world Y (higher = brighter)\n  const tA = (a[1] - MIN_Y) / (MAX_Y - MIN_Y); // 0..1\n  const tB = (b[1] - MIN_Y) / (MAX_Y - MIN_Y);\n  // Cylinder local Y: -height/2 = point A, +height/2 = point B (after transform)\n  const positions = geo.attributes.position;\n  const colors = new Float32Array(positions.count * 3);\n\n  for (let i = 0; i < positions.count; i++) {\n    const y = positions.getY(i);\n    const along = (y + height / 2) / height; // 0 at bottom (A), 1 at top (B)\n    const tint = 0.9 + 0.45 * (tA + (tB - tA) * along); // 0.55–1.0\n    colors[i * 3] = baseColor.r * tint;\n    colors[i * 3 + 1] = baseColor.g * tint;\n    colors[i * 3 + 2] = baseColor.b * tint;\n  }\n\n  geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));\n  return geo;\n}\n\n/** Compute position + quaternion to place a cylinder between two points */\nfunction edgeTransform(a: THREE.Vector3Tuple, b: THREE.Vector3Tuple): { pos: THREE.Vector3; quat: THREE.Quaternion } {\n  const va = new THREE.Vector3(...a);\n  const vb = new THREE.Vector3(...b);\n  const mid = va.clone().add(vb).multiplyScalar(0.5);\n  const dir = vb.clone().sub(va).normalize();\n  const quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir);\n  return { pos: mid, quat };\n}\n\nconst EDGE_RADIUS = 0.035;\nconst EDGE_PAIRS: [THREE.Vector3Tuple, THREE.Vector3Tuple][] = [\n  [V0, V1], [V0, V2], [V0, V3], [V1, V2], [V1, V3], [V2, V3],\n];\n\n/** Build a single-triangle geometry with UVs */\nfunction makeFaceGeo(verts: THREE.Vector3Tuple[], normal: THREE.Vector3): THREE.BufferGeometry {\n  const geo = new THREE.BufferGeometry();\n  const pos = new Float32Array([\n    ...verts[0], ...verts[1], ...verts[2],\n  ]);\n  const norms = new Float32Array([\n    normal.x, normal.y, normal.z,\n    normal.x, normal.y, normal.z,\n    normal.x, normal.y, normal.z,\n  ]);\n  const uvs = new Float32Array([0.5, 1.0, 0.0, 0.0, 1.0, 0.0]);\n  geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));\n  geo.setAttribute('normal', new THREE.BufferAttribute(norms, 3));\n  geo.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));\n  return geo;\n}\n\n/**\n * Precompute target quaternion for each face.\n * Build rotation from orthonormal basis: {right, up, normal} → {+X, +Y, +Z}\n */\nconst TARGET_QUATS = FACES.map((verts, fi) => {\n  const normal = NORMALS[fi];\n  const cx = (verts[0][0] + verts[1][0] + verts[2][0]) / 3;\n  const cy = (verts[0][1] + verts[1][1] + verts[2][1]) / 3;\n  const cz = (verts[0][2] + verts[1][2] + verts[2][2]) / 3;\n  const up = new THREE.Vector3(\n    verts[0][0] - cx, verts[0][1] - cy, verts[0][2] - cz,\n  ).normalize();\n  const right = new THREE.Vector3().crossVectors(up, normal).normalize();\n  const m = new THREE.Matrix4().makeBasis(right, up, normal).transpose();\n  return new THREE.Quaternion().setFromRotationMatrix(m);\n});\n\nexport default function TetrahedronDie({ rollTrigger, onResult, primary, primaryDark }: Props) {\n  const groupRef = useRef<THREE.Group>(null);\n  const prevTrigger = useRef(rollTrigger);\n  const hasReported = useRef(false);\n\n  const spinning = useRef(false);\n  const spinStart = useRef(0);\n  const spinAxis = useRef(new THREE.Vector3(1, 1, 0).normalize());\n  const spinSpeed = useRef(8);\n  const targetResult = useRef(0);\n  const targetQuat = useRef(new THREE.Quaternion());\n  const settleStartQuat = useRef(new THREE.Quaternion());\n  const settleStart = useRef(0);\n\n  const SPIN_DURATION = 1.5;\n  const SETTLE_DURATION = 0.3;\n  const FLASH_DURATION = SETTLE_DURATION;\n\n  const flashing = useRef(false);\n  const flashStart = useRef(0);\n\n  const edgeBaseColor = useMemo(() => new THREE.Color(darken(primary, 0.1)), [primary]);\n\n  const faceMeshRefs = useRef<(THREE.Mesh | null)[]>([null, null, null, null]);\n  const worldNormal = useRef(new THREE.Vector3());\n  const camDir = new THREE.Vector3(0, 0, 1);\n\n  const faceData = useMemo(() =>\n    FACES.map((verts, fi) => ({\n      geometry: makeFaceGeo(verts, NORMALS[fi]),\n      texture: makeFaceTexture(FACE_RESULTS[fi], primary),\n    })),\n    [primary]);\n\n  const edges = useMemo(() =>\n    EDGE_PAIRS.map(([a, b]) => ({\n      geo: makeEdgeCylinder(a, b, EDGE_RADIUS, edgeBaseColor),\n      ...edgeTransform(a, b),\n    })),\n    [edgeBaseColor]);\n\n  // Roll trigger\n  useEffect(() => {\n    if (rollTrigger === 0) return;\n    if (rollTrigger === prevTrigger.current) return;\n    prevTrigger.current = rollTrigger;\n\n    hasReported.current = false;\n    spinning.current = true;\n    spinStart.current = 0;\n\n    // Random axis with balanced components for varied tumble\n    const sx = Math.random() < 0.5 ? -1 : 1;\n    const sy = Math.random() < 0.5 ? -1 : 1;\n    const sz = Math.random() < 0.5 ? -1 : 1;\n\n    spinAxis.current\n      .set(\n        sx * (0.5 + Math.random() * 0.5),\n        sy * (0.5 + Math.random() * 0.5),\n        sz * (0.5 + Math.random() * 0.5)\n      )\n      .normalize();\n\n    spinSpeed.current = 14 + Math.random() * 4;\n\n    targetResult.current = Math.floor(Math.random() * 4) + 1;\n    const faceIndex = FACE_RESULTS.indexOf(targetResult.current);\n    targetQuat.current.copy(TARGET_QUATS[faceIndex]);\n  }, [rollTrigger]);\n\n  // Tint faces: front-facing = true color, others darken + flash & scale punch\n  const tintFaces = () => {\n    if (!groupRef.current) return;\n\n    // Flash decay: 1 → 0 over FLASH_DURATION\n    let flash = 0;\n    if (flashing.current && flashStart.current > 0) {\n      const flashElapsed = performance.now() / 1000 - flashStart.current;\n      const ft = Math.min(flashElapsed / FLASH_DURATION, 1);\n      flash = 1 - ft;\n      if (ft >= 1) flashing.current = false;\n\n      // Scale punch: 1 → 1.15 → 1 (quick pop out then back)\n      const scalePunch = 1 + 0.15 * Math.sin(ft * Math.PI);\n      groupRef.current.scale.setScalar(scalePunch);\n    }\n\n    for (let i = 0; i < 4; i++) {\n      const mesh = faceMeshRefs.current[i];\n      if (!mesh) continue;\n      worldNormal.current.copy(NORMALS[i]).applyQuaternion(groupRef.current.quaternion);\n      const dot = worldNormal.current.dot(camDir);\n      let brightness = 0.35 + 0.9 * Math.max(0, dot);\n      // Flash: all faces wash toward white then fade back\n      if (flash > 0) {\n        brightness = brightness + (2.0 - brightness) * flash * 0.6;\n      }\n      (mesh.material as THREE.MeshBasicMaterial).color.setScalar(brightness);\n    }\n  };\n\n  useFrame((_, delta) => {\n    if (!groupRef.current) return;\n\n    tintFaces();\n\n    if (!spinning.current) return;\n\n    if (spinStart.current === 0) {\n      spinStart.current = performance.now() / 1000;\n      settleStart.current = 0;\n    }\n\n    const elapsed = performance.now() / 1000 - spinStart.current;\n\n    if (elapsed < SPIN_DURATION) {\n      const progress = elapsed / SPIN_DURATION;\n      const decay = Math.pow(1 - progress, 1.5);\n      groupRef.current.rotateOnAxis(spinAxis.current, spinSpeed.current * decay * delta);\n    } else {\n      if (settleStart.current === 0) {\n        settleStart.current = performance.now() / 1000;\n        settleStartQuat.current.copy(groupRef.current.quaternion);\n      }\n\n      const settleElapsed = performance.now() / 1000 - settleStart.current;\n      const t = Math.min(settleElapsed / SETTLE_DURATION, 1);\n      const eased = 1 - Math.pow(1 - t, 3);\n\n      groupRef.current.quaternion.copy(settleStartQuat.current).slerp(targetQuat.current, eased);\n\n      if (t >= 1) {\n        spinning.current = false;\n        groupRef.current.quaternion.copy(targetQuat.current);\n\n        if (!hasReported.current) {\n          hasReported.current = true;\n          flashing.current = true;\n          flashStart.current = performance.now() / 1000;\n          onResult(targetResult.current);\n        }\n      }\n    }\n  });\n\n  return (\n    <group ref={groupRef} position={[0, -0.35, 0]}>\n      {faceData.map((face, i) => (\n        <mesh key={i} ref={el => { faceMeshRefs.current[i] = el; }} geometry={face.geometry}>\n          <meshBasicMaterial map={face.texture} />\n        </mesh>\n      ))}\n      {edges.map((edge, i) => (\n        <mesh key={`edge-${i}`} geometry={edge.geo} position={edge.pos} quaternion={edge.quat}>\n          <meshBasicMaterial vertexColors />\n        </mesh>\n      ))}\n    </group>\n  );\n}\n","import { Canvas } from '@react-three/fiber';\nimport TetrahedronDie from './TetrahedronDie';\n\ninterface Props {\n  rollTrigger: number;\n  onResult: (result: number) => void;\n  onClick: () => void;\n  primary: string;\n  primaryDark: string;\n}\n\nexport default function D4Scene({ rollTrigger, onResult, onClick, primary, primaryDark }: Props) {\n  return (\n    <Canvas\n      flat\n      camera={{ position: [0, 0, 5.5], fov: 40 }}\n      gl={{ alpha: true, antialias: true }}\n      style={{ background: 'transparent', cursor: 'pointer' }}\n      onClick={onClick}\n    >\n      <ambientLight intensity={0.55} color=\"#ffffff\" />\n      <directionalLight position={[0, 0, 5]} intensity={0.45} color=\"#ffffff\" />\n      <directionalLight position={[3, 5, 5]} intensity={0.15} color=\"#ffffff\" />\n      <TetrahedronDie\n        rollTrigger={rollTrigger}\n        onResult={onResult}\n        primary={primary}\n        primaryDark={primaryDark}\n      />\n    </Canvas>\n  );\n}\n"],"names":["FACE_RESULTS","S","rt3","Math","sqrt","rt6","V0","V1","V2","V3","FACES","NORMALS","map","f","a","b","c","va","THREE","vb","vc","sub","cross","normalize","computeNormal","parseColor","color","rgbMatch","match","h","replace","n","parseInt","length","split","join","contrastText","bg","lum","r","g","s","pow","luminance","makeFaceTexture","num","primary","size","canvas","document","createElement","width","height","ctx","getContext","fillStyle","fillRect","textColor","font","textAlign","textBaseline","fillText","String","tex","needsUpdate","ALL_VERTS","MIN_Y","min","v","MAX_Y","max","makeEdgeCylinder","radius","baseColor","distanceTo","geo","tA","tB","positions","attributes","position","colors","Float32Array","count","i","tint","getY","setAttribute","EDGE_PAIRS","makeFaceGeo","verts","normal","pos","norms","x","y","z","uvs","TARGET_QUATS","fi","cx","cy","cz","up","right","crossVectors","m","makeBasis","transpose","setFromRotationMatrix","TetrahedronDie","_ref","rollTrigger","onResult","primaryDark","groupRef","useRef","prevTrigger","hasReported","spinning","spinStart","spinAxis","spinSpeed","targetResult","targetQuat","settleStartQuat","settleStart","flashing","flashStart","edgeBaseColor","useMemo","ratio","round","concat","darken","faceMeshRefs","worldNormal","camDir","faceData","geometry","texture","edges","_ref2","_objectSpread","mid","clone","add","multiplyScalar","dir","quat","setFromUnitVectors","edgeTransform","useEffect","current","sx","random","sy","sz","set","floor","faceIndex","indexOf","copy","useFrame","_","delta","tintFaces","flash","flashElapsed","performance","now","ft","scalePunch","sin","PI","scale","setScalar","mesh","applyQuaternion","quaternion","dot","brightness","material","elapsed","progress","decay","rotateOnAxis","settleElapsed","t","eased","slerp","_jsxs","ref","children","face","_jsx","el","edge","vertexColors","D4Scene","onClick","Canvas","flat","camera","fov","gl","alpha","antialias","style","background","cursor","intensity"],"sourceRoot":""}